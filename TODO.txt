(1) Refatorar o modulo communication.py (soh deve conter coisas de comunicacao)

(2) Melhorar os helps (incluir exit e, talvez, colocar os comandos por extenso ao inves de abreviado, pois ajuda na memorizacao/utilizacao). Raramente os bons sistemas utilizam abreviacao de comandos. Exemplo: eh "show" e n√£o "sc". Ou ainda, "show chain", "show ip", "show port", ao inves de "sc".

(3) KeepAlive: manter uma conexao aberta com o Keeper (nao fica abrindo e fechando). Na hora que o cliente more, o Keeper encerra a conexao e considera o cliente "morto".

(4) Ha algo de errado com o Keeper. Se fecho o cliente e abro novamente, nao funciona, nao rola.

(5) Melhorar a parte dos listen de todos os "trens". Nao deve precisar ficar trocando de porta toda hora. Configurar os sockets TCP para reutilizacao de portas (no codigo Python).

(6) O keeper precisa ter dois pools de threads, uma para receber as conexoes (uma thread por conexao) e outra para realizar conexoes (uma thread por cliente).

(7) O cliente eh que deve indicar para o keeper a porta que ele vai estar escutando. Eis um exemplo de codigo para pegar uma porta livre no cliente.

import socket
from contextlib import closing

def find_free_port():
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind(('', 0))
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        return s.getsockname()[1]

def get_free_tcp_port():
    tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp.bind(('', 0))
    addr, port = tcp.getsockname()
    tcp.close()
    return port

def get_free_tcp_address():
    tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp.bind(('', 0))
    host, port = tcp.getsockname()
    tcp.close()
    return 'tcp://{host}:{port}'.format(**locals())

